<!doctype html><html lang=en><head><title>Artificial Neural Networks For Applied Mathematicians // Affan Shoukat</title><link rel="shortcut icon" href=../../favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.83.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Dr. Affan Shoukat"><meta name=description content><link rel=stylesheet href=https://affans.github.io/personal/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css><meta name=twitter:card content="summary"><meta name=twitter:title content="Artificial Neural Networks For Applied Mathematicians"><meta name=twitter:description content="Consider a neural network with $L$ layers, defined by a mapping $\mathbb{R}^{n_1} \rightarrow \mathbb{R}^{n_L}$ where $n_1$ and $n_L$ are the dimensions of the initial input and final output."><meta property="og:title" content="Artificial Neural Networks For Applied Mathematicians"><meta property="og:description" content="Consider a neural network with $L$ layers, defined by a mapping $\mathbb{R}^{n_1} \rightarrow \mathbb{R}^{n_L}$ where $n_1$ and $n_L$ are the dimensions of the initial input and final output."><meta property="og:type" content="article"><meta property="og:url" content="https://affans.github.io/personal/post/nn-back-prop/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-05-09T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-09T00:00:00+00:00"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css integrity=sha384-t5CR+zwDAROtph0PXGte6ia8heboACF9R5l/DiY+WZ3P2lxNgvJkQk5n7GPvLMYw crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js integrity=sha384-FaFLTlohFghEIZkw6VGwmf9ISTubWAVYW8tG8+w2LAIftJEULZABrF9PPFv+tVkH crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/contrib/auto-render.min.js integrity=sha384-bHBqxz8fokvgoJ/sc17HODNxa42TlaEhB+w8ZJXTc2nZf1VgEaFZeZvT4Mznfz0v crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><header class=app-header><a href=https://affans.github.io/personal><img class=app-header-avatar src=../../images/profile.jpg alt="Dr. Affan Shoukat"></a><h1>Affan Shoukat</h1><nav class=app-header-menu><a class=app-header-menu-item href=../../posts/>Posts</a>
-
<a class=app-header-menu-item href=../../about/>About</a></nav><p>Personal and Academic</p></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>Artificial Neural Networks For Applied Mathematicians</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>May 9, 2021</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>4 min read</div></div></header><div class=post-content><p>Consider a neural network with $L$ layers, defined by a mapping $\mathbb{R}^{n_1} \rightarrow \mathbb{R}^{n_L}$ where $n_1$ and $n_L$ are the dimensions of the initial input and final output. Let $W^{[l]} \in \mathbb{R}^{n_l \times n_{l - 1}}$ denote the matrix of weights at layer $l$. Similarly, let $b^{[l]} \in \mathbb{R}^{n_l}$ be the vector of biases for layer $l$. Given an input $x \in \mathbb{R}^{n_1}$, the neural network can then be succinctly described by<br>$$
\begin{align}
a^{[1]} &= x \in \mathbb{R}^{n_1} \newline
a^{[l]} &= \sigma \left( W^{[l]} a^{[l - 1]} + b^{[l]} \right) \quad \text{ for } l = 2, 3, \ldots, L
\end{align}
$$
where $\sigma$ is some activation function. The expression $W^{[l]} a^{[l - 1]} + b^{[l]} \in \mathbb{R}^{n_l}$ is the *weighted input* to evaluate the network at layer $l$, ultimately feeding data forward through the network to produce a final output $a^{[L]} \in \mathbb{R}^{n_L}$. The values of $W$ and $b$ are estimated by training the neural network, often involving optimizing or minimizing the quadratic function:
$$
C(p) = \frac{1}{N} \sum_{i = 1}^{N} \lVert y(x^{i}) - a^{[L]}(x^{i}) \rVert^2_2
$$
where $\{ y(x^{i}) \} _ {i = 1}^{N} \in \mathbb{R}^{n_L}$ are target outputs for $N$ given inputs $\{ x^{i} \} _ {i = 1}^{N}$ and $p \in \mathbb{R}^{s}$ is a $s$-dimensional vector of parameters containing the weights and biases. The function $C$ is a linear combination of individual terms that runs over the training data and is referred to as the cost function. Note its
dependence on $p$ rather than data. The classic method for optimization is the steepest descent method, an iterative procedure that computes a sequence of vectors in $\mathbb{R}^{s}$ with the aim of converging to a vector that minimizes the cost function. Simply speaking, given a current vector $p$, choose a perturbation $\Delta p$ so that the $C(p + \Delta p)$ represents an improvement. Taking the Taylor series, and ignoring higher order terms, we have
$$
C(p + \Delta p) \approx C(p) + \nabla C(p)^{T} \Delta p
$$
where $\nabla C(p)$ is the <a href=https://en.wikipedia.org/wiki/Gradient>gradient</a> of $C$ w.r.t to $p$. Similar to $C$, the gradient $\nabla C(p)$ is a linear combination of individual terms that runs over the training data. To minimize $C$, we choose $\Delta p$ to make $\nabla C(p)^{T} \Delta p$ as negative as possible. Applying the Cauchy-Schwarz inequality (which states $f, g \in \mathbb{R}^s$, we have $|f^Tg| \leq \lVert f \rVert_2 \lVert g \rVert_2$ so the most negative that $f^Tg$ can be is $\lVert f \rVert_2 \lVert g \rVert_2$, which happens when $f = -g$), we choose $\Delta p$ to lie in the direct of $-\nabla C(p)$. This leads to the update $p \rightarrow p - \eta \nabla C(p)$ where $\eta$ is a small step size, also known as the learning rate. The sequence of vectors is continously updated until some stopping criterion is met. This defines the steepest descent method.</p><p>In general, computing the cost function (or more precisely, the gradient vector within) is prohibitively expensive. Indeed, it involves summing individual terms that run over the training data since,<br>$$
\nabla C(p) = \frac{1}{N} \sum_{i = 1}^N \nabla \lVert y(x^{{i}})-a^{[L]}(x^{{i}})\rVert_{2}^{2}
$$
where the parameter for the derivative $p$ arises only implicitly through the neural network computation layers $a^{[l]}, l = \{1, 2, \ldots L\}$. When there are a large number of parameters and a large number of training points, computing this gradient vector at every iteration of the steepest descent method is not feasible. Cheaper alternative exists such as replacing the mean of the individual gradients by the gradient at a single, randomly chosen training point, that is: $\nabla C(p) = \frac{1}{N} \nabla \lVert y(x^{{j}})-a^{[L]}(x^{{j}})\rVert_{2}^{2}$ where $j$ is some fixed integer sampled uniformly from $\{1, 2, 3, \ldots, N\}$. This is also known as the stochastic gradient method. Ofcourse, now that the mean was traded for a single sample, the update $p \rightarrow p - \eta \nabla C(p)$ is not gauranteed to reduce the overall cost. This can be remedied by other modified methods. For example, the index $j$ can be chosen by sampling with replacement &ndash; after using a training point, it is returned to the training set and is equally likely to be picked again for the next cost computation. Batching techniques also exist, where instead of taking the mean over all data points, we consider a smaller sample $m \ll N$.</p><p>We are now in a position to apply the stochastic gradient method in order to train an artificial neural network. Our task is to compute partial derivatives of the cost function $C$ with respect to the parameter vector $p$, or more specfically to each of $w_{j,k}^{[l]}$ and $b_j^{[l]}$. The algorithm used to compute these partial derivatives (the gradient) with respect to a cost function is also known as **Back Propagation**, described in more detail in a follow up blog post to be published later.</p></div><div class=post-footer></div></article></main></body></html>